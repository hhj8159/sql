CREATE TABLE HEIGHT_INFO AS
SELECT STUDNO, NAME, HEIGHT FROM STUDENT WHERE 1=0;

CREATE TABLE WEIGHT_INFO AS
SELECT STUDNO, NAME, HEIGHT WEIGHT FROM STUDENT WHERE 1=0;

-- 테이블 확인
SELECT * FROM HEIGHT_INFO;
SELECT * FROM WEIGHT_INFO;

-- DELETE 행별로 지움, DROP 테이블 자체를 지움, TRUNCATE 테이블을 비움(복구불가)
TRUNCATE TABLE HEIGHT_INFO;
TRUNCATE TABLE WEIGHT_INFO;

-- 2학년 이상의 학생, HEIGHT_INFO에는 학번, 이름, 키, WEIGHT_INFO에는 학번 이름 체중 입력
INSERT ALL
INTO HEIGHT_INFO VALUES(STUDNO, NAME, HEIGHT)
INTO WEIGHT_INFO VALUES(STUDNO, NAME, WEIGHT)
SELECT * FROM STUDENT s WHERE GRADE >= '2';

-- 2학년 이상의 학생, HEIGHT_INFO에는 학번, 이름, 키, WEIGHT_INFO에는 학번 이름 체중 입력
-- INSERT ALL CONDITIONAL
-- HEIGHT_INFO 에는 키 170이상만
-- WEIGHT_INFO 에는 체중 70이상만
INSERT FIRST
WHEN HEIGHT >= 170 THEN
	INTO HEIGHT_INFO VALUES(STUDNO, NAME, HEIGHT)
WHEN WEIGHT >= 70 THEN
	INTO WEIGHT_INFO VALUES(STUDNO, NAME, WEIGHT)
SELECT * FROM STUDENT s WHERE GRADE >= '2';


-- PIVOING 
CREATE TABLE SALES (
	SALES_NO NUMBER,
	WEEK_NO NUMBER,
	SALES_MON NUMBER,
	SALES_TUE NUMBER,
	SALES_WED NUMBER,
	SALES_THU NUMBER,
	SALES_FRI NUMBER
);

CREATE TABLE SALES_DATA (
	SALES_NO NUMBER,
	WEEK_NO NUMBER,
	DAY_NO NUMBER,
	SALES NUMBER
);

INSERT INTO SALES VALUES (1191, 4, 100, 150, 80, 60, 120);
INSERT INTO SALES VALUES (1102, 5, 300, 300, 230, 120, 150);

TRUNCATE TABLE SALES_DATA;


INSERT ALL
INTO SALES_DATA VALUES (SALES_NO, WEEK_NO, 1, SALES_MON)
INTO SALES_DATA VALUES (SALES_NO, WEEK_NO, 2, SALES_TUE)
INTO SALES_DATA VALUES (SALES_NO, WEEK_NO, 3, SALES_WED)
INTO SALES_DATA VALUES (SALES_NO, WEEK_NO, 4, SALES_THU)
INTO SALES_DATA VALUES (SALES_NO, WEEK_NO, 5, SALES_FRI)
SELECT * FROM SALES;

SELECT * FROM SALES;

SELECT 
	SALES_NO, 
	WEEK_NO,
	MAX(DECODE(DAY_NO, 1, SALES)) M, 
	MAX(DECODE(DAY_NO, 2, SALES)) T, 
	MAX(DECODE(DAY_NO, 3, SALES)) W, 
	MAX(DECODE(DAY_NO, 4, SALES)) TH, 
	MAX(DECODE(DAY_NO, 5, SALES)) F	
FROM SALES_DATA
GROUP BY SALES_NO, WEEK_NO;
ORDER BY 1, 3;


-- UPDATE
-- 교수번호가 9903인 교수의 직급을 부교수로 수정 평가에 나올듯
SELECT * FROM PROFESSOR WHERE PROFNO = 9903;

-- 교수번호가 9903인 교수의 직급을 전임교수로 수정, 아이디를 'littlePascal'로 수정, 급여를 20올린 데이터로 수정
UPDATE PROFESSOR SET 
	"POSITION" = '전임교수',
	USERID = 'litPascal',
	SAL = SAL + 20
WHERE PROFNO = 9903; -- WHERE절 생략하면 모든 교수의 직급이 부교수로 바뀐다


-- DELETE 

-- 컴퓨터공학과 소속 학생 데이터 삭제
DELETE 
FROM STUDENT
WHERE DEPTNO = (
	SELECT DEPTNO FROM DEPARTMENT WHERE DNAME = '컴퓨터공학과'
);

CREATE TABLE T_STU AS
SELECT * FROM STUDENT;

DROP TABLE STUDENT;

RENAME T_STU TO STUDENT;


-- MERGE

-- PROFESSOR_TEMP 테이블생성, 교수 직급만 가져와서 생성
CREATE TABLE PROFESSOR_TEMP AS
SELECT * FROM PROFESSOR p WHERE "POSITION" = '교수';

TRUNCATE TABLE PROFESSOR_TEMP;

SELECT * FROM PROFESSOR_TEMP;

UPDATE PROFESSOR_TEMP SET 
	POSITION = '명예교수';

INSERT INTO PROFESSOR_TEMP VALUES (9999, '김도경', 'arom', '전임강사', 200, SYSDATE, 10, 101);


MERGE INTO PROFESSOR p
	USING PROFESSOR_TEMP PT
	ON (P.PROFNO = PT.PROFNO)
WHEN MATCHED THEN
	UPDATE SET P.POSITION = PT.POSITION
-- UPDATE
WHEN NOT MATCHED THEN
	INSERT VALUES(PT.PROFNO, PT.NAME, PT.USERID, PT.POSITION, PT.SAL, PT.HIREDATE, PT.COMM, PT.DEPTNO);
-- 
SELECT * FROM PROFESSOR;
DELETE FROM PROFESSOR p WHERE POSITION = '명예교수';

-- 트랜잭션 - 원자성, 일관성, 독립성, 지속성 (평가 나오?)


-- 시퀀스
-- 게시판 용 테이블 생성
DROP TABLE BOARD;

CREATE TABLE BOARD (
	NO NUMBER PRIMARY KEY,
	TITLE VARCHAR(4000),
	CONTENT CLOB,
	WERITER VARCHAR(1000),
	REGDATE DATE DEFAULT SYSDATE
);
CREATE SEQUENCE SEQ_BOARD;

INSERT INTO BOARD(NO,TITLE, CONTENT, WERITER) VALUES (2, '제목', '내용', '새똥이');

SELECT ROWNUM, B.* FROM BOARD B ;

COMMIT;

INSERT INTO BOARD(NO,TITLE, CONTENT, WERITER)
SELECT SEQ_BOARD.NEXTVAL NO, TITLE, CONTENT, WERITER FROM BOARD;


-- CURRVAL, NEXTVAL  -INSERT, UPDATE에서 사용
-- 서브쿼리, GROUP BY, HAVING, ORDER BY, DISTINCT와 컬럼 기본값으로 사용불가 

-- 원장성 테이블(MASTER TABLE) 업무의 핵심개체, 가장 최신의 상태 유지
-- 이력 테이블(HISTORY TABLE) 마스터 테이블의 변경된 상태 속성을 보관, 그 정보를 구간으로 구분하는 형태
-- 거래성 테이블(TRANSACTIONAL TABLE) 행위에 대한 테이블, 등록만 됨 변경없음
-- 양면성 테이블(DUPLICITY TABLE) 행위에 대한 테이블이지만 UPDATE 가능

-- PK(PRIMARY KEY) = UK(UNIQUE KEY)중복금지) + NN(NOT NULL)

--











